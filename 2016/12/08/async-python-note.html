
<!DOCTYPE html>
<html lang="zh">
<head>
  <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,400italic' rel='stylesheet' type='text/css'>

    <link rel="stylesheet" type="text/css" href="../../../theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="../../../theme/pygments/default.min.css">
  <link rel="stylesheet" type="text/css" href="../../../theme/font-awesome/css/font-awesome.min.css">


    <link href="https://blog.huiyiqun.me/feed.xml" type="application/atom+xml" rel="alternate" title="Notepad Atom">



  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="" />

    <!-- Chrome, Firefox OS and Opera -->
    <meta name="theme-color" content="white">
    <!-- Windows Phone -->
    <meta name="msapplication-navbutton-color" content="white">
    <!-- iOS Safari -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<meta name="author" content="Hui Yiqun" />
<meta name="description" content="About 一般来说说到 Python 都会说这是一种十分低效的语言 ， 慢等等 ， 然而之前用 Gevent 做了一个 restful， 发现其实性能还不错 。 其实 Python 很慢这一点当然是不错的 ， 不适合直接用来作复杂算法的实现 。 但是当我们需要实现 Web 服务器等软件时 ， 性能的瓶颈实际并不在 CPU 上 ， 多数时间我们都在等待 IO， 如果 IO 需要 1s， 这个时候你用 Python 实现一段代码运行需要 0.01s， 和你用 C 实现一段代码运行需要 0.0001s 有什么可感知的区别吗 ？ 所以最重要的是如何地让用户请求不阻塞 ， 充分地让 IO 跑满 。 最早人们通过多进程来解决这个问题 ， 后来发现进程实在是太笨重 ， 转而使用线程来解决这个问题 ， 但是线程切换对于大量短时 io 依然过重 。 所以最后人们转而开始强调并发 ， 不再强调并行 ， 也就是所谓的异步 …" />
<meta name="keywords" content="">
<meta property="og:site_name" content="Notepad"/>
<meta property="og:title" content="异步Python学习笔记"/>
<meta property="og:description" content="About 一般来说说到 Python 都会说这是一种十分低效的语言 ， 慢等等 ， 然而之前用 Gevent 做了一个 restful， 发现其实性能还不错 。 其实 Python 很慢这一点当然是不错的 ， 不适合直接用来作复杂算法的实现 。 但是当我们需要实现 Web 服务器等软件时 ， 性能的瓶颈实际并不在 CPU 上 ， 多数时间我们都在等待 IO， 如果 IO 需要 1s， 这个时候你用 Python 实现一段代码运行需要 0.01s， 和你用 C 实现一段代码运行需要 0.0001s 有什么可感知的区别吗 ？ 所以最重要的是如何地让用户请求不阻塞 ， 充分地让 IO 跑满 。 最早人们通过多进程来解决这个问题 ， 后来发现进程实在是太笨重 ， 转而使用线程来解决这个问题 ， 但是线程切换对于大量短时 io 依然过重 。 所以最后人们转而开始强调并发 ， 不再强调并行 ， 也就是所谓的异步 …"/>
<meta property="og:locale" content="zh_CN"/>
<meta property="og:url" content="../../../2016/12/08/async-python-note.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2016-12-08 16:52:11+08:00"/>
<meta property="article:modified_time" content="2016-12-31 21:10:53+08:00"/>
<meta property="article:author" content="../../../author/hui-yiqun.html">
<meta property="article:section" content="Python"/>
<meta property="og:image" content="https://secure.gravatar.com/avatar/e96680ba97e70a013f818edde6753ca8?s=120">

  <title>Notepad &ndash; 异步Python学习笔记</title>

</head>
<body>
<!-- Google Tag Manager -->
<noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-NW57T8B"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-NW57T8B');</script>
<!-- End Google Tag Manager -->  <aside>
    <div>
      <a href="../../..">
        <img src="https://secure.gravatar.com/avatar/e96680ba97e70a013f818edde6753ca8?s=120" alt="Notepad" title="Notepad">
      </a>
      <h1><a href="../../..">Notepad</a></h1>

<p>The Power of Writing</p>
      <nav>
        <ul class="list">

          <li><a href="https://tuna.moe/" target="_blank">TUNA</a></li>
        </ul>
      </nav>

      <ul class="social">
        <li><a class="sc-github" href="https://github.com/huiyiqun" target="_blank"><i class="fa fa-github"></i></a></li>
        <li><a class="sc-stack-overflow" href="https://stackoverflow.com/users/2825773/given92" target="_blank"><i class="fa fa-stack-overflow"></i></a></li>
        <li><a class="sc-google-plus" href="https://plus.google.com/u/0/107187513671494024284" target="_blank"><i class="fa fa-google-plus"></i></a></li>
        <li><a class="sc-telegram" href="https://telegram.me/huiyiqun" target="_blank"><i class="fa fa-telegram"></i></a></li>
        <li><a class="sc-rss" href="https://blog.huiyiqun.me/feed.xml" target="_blank"><i class="fa fa-rss"></i></a></li>
      </ul>
    </div>


  </aside>
  <main>


<article class="single">
  <header>
    <h1 id="async-python-note">异步Python学习笔记</h1>
    <p>
          Posted on Thu 08 December 2016 in <a href="../../../category/python.html">Python</a>


    </p>
  </header>


  <div>
    <h1>About</h1>
<p> 一般来说说到 Python 都会说这是一种十分低效的语言 ， 慢等等 ， 然而之前用 Gevent 做了一个 restful， 发现其实性能还不错 。</p>
<p> 其实 Python 很慢这一点当然是不错的 ， 不适合直接用来作复杂算法的实现 。 但是当我们需要实现 Web 服务器等软件时 ，
 性能的瓶颈实际并不在 CPU 上 ， 多数时间我们都在等待 IO， 如果 IO 需要 1s， 这个时候你用 Python 实现一段代码运行需要 0.01s，
 和你用 C 实现一段代码运行需要 0.0001s 有什么可感知的区别吗 ？</p>
<p> 所以最重要的是如何地让用户请求不阻塞 ， 充分地让 IO 跑满 。 最早人们通过多进程来解决这个问题 ， 后来发现进程实在是太笨重 ，
 转而使用线程来解决这个问题 ， 但是线程切换对于大量短时 io 依然过重 。 所以最后人们转而开始强调并发 ， 不再强调并行 ，
 也就是所谓的异步 。  这就是为什么 Python 这样的有 <a href="https://wiki.python.org/moin/GlobalInterpreterLock">GIL</a> 存在的 ，
 串行执行的语言 ， 在 web 开发上依然能有一席之地的原因 。 所以要用 Python 高效的实现服务 ， 良好地异步是必不可少的 。</p>
<p>Python 3.4  新加了 <a href="https://docs.python.org/3/library/asyncio.html">asyncio</a>， 一直很感兴趣 ， 但是也没时间去深入研究 。</p>
<p> 最近在实验室需要做一个 FTP，<a href="https://github.com/giampaolo/pyftpdlib">pyftpdlib</a> 是一个十分优秀的 FTP 服务器实现 ，
 其本身的实现是基于异步的 ， 同时也支持线程和进程模型 。 当然考虑到性能问题 ， 最后肯定需要采用异步模型 。
 但是在这里我遇到了一个问题 ，pyftpdlib 本身有自己的异步 IO loop， 如果强行上 gevent 的 monkey_patch 有可能导致各种奇怪的 bug？</p>
<p> 基于这个考虑 ， 我决定系统地对 Python 的整个异步生态了解一遍 ， 以下是一些笔记 。</p>
<p> 因为我用 Python 时间也不算特别长 ， 所以特别久远的异步实现 ， 像 twisted 我就不提了 。
 下面主要是围绕 asyncio 出现之前比较流行的 gevent 和现在官方实现的 asyncio 进行分析 。</p>
<h1>greenlet</h1>
<p><a href="https://greenlet.readthedocs.io/en/latest/">greenlet</a> 是 Gevent 的依赖之一 ， 它实现了一种叫 "tasklet" 的微线程 。</p>
<p> 官网上的两个例子很适合理解 ， 我就摘抄到这里了 ：</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">greenlet</span> <span class="kn">import</span> <span class="n">greenlet</span>

<span class="k">def</span> <span class="nf">test1</span><span class="p">():</span>
    <span class="k">print</span> <span class="mi">12</span>
    <span class="n">gr2</span><span class="o">.</span><span class="n">switch</span><span class="p">()</span>
    <span class="k">print</span> <span class="mi">34</span>

<span class="k">def</span> <span class="nf">test2</span><span class="p">():</span>
    <span class="k">print</span> <span class="mi">56</span>
    <span class="n">gr1</span><span class="o">.</span><span class="n">switch</span><span class="p">()</span>
    <span class="k">print</span> <span class="mi">78</span>

<span class="n">gr1</span> <span class="o">=</span> <span class="n">greenlet</span><span class="p">(</span><span class="n">test1</span><span class="p">)</span>
<span class="n">gr2</span> <span class="o">=</span> <span class="n">greenlet</span><span class="p">(</span><span class="n">test2</span><span class="p">)</span>
<span class="n">gr1</span><span class="o">.</span><span class="n">switch</span><span class="p">()</span>
</pre></div>


<p> 这个例子很简单 ， 首先定义了两个函数作为 <code>greenlet</code> 的入口 ， 在外部定义两个 <code>greenlet</code>， 然后 <code>switch</code> 到 <code>gr1</code>，
 这个时候 <code>gr1</code> 会 <code>switch</code> 到 <code>gr2</code>， 然后 <code>gr2</code> 重新 <code>switch</code> 到 <code>gr1</code>，<code>gr1</code> 结束退出 ， 整个程序结束退出 。
 程序运行的输出如下 ：</p>
<div class="highlight"><pre><span></span>12
56
34
</pre></div>


<p> 我们可以看到 ：</p>
<ol>
<li> 程序依然是串行执行的 ， 并没有任何并行存在 。</li>
<li> 我们成功的在两个函数的串行执行之间进行了切换 ， 也就是所谓的协程 。</li>
<li> 在 API 的结构上 ， 很像线程 ， 但是没有线程的隐式切换 。</li>
</ol>
<p> 主意到 ，78 并没有被输出 ， 因为 <code>gr2.switch</code> 只被调用了一次 ， 因此 <code>switch</code> 出 <code>gr2</code> 之后就不会再进去了 。</p>
<p> 如果在程序的最后加上 <code>gr2.switch()</code>， 就能看到 78 输出了 .</p>
<p>Greenlet 的另一个例子更有实用价值一些 ， 假设你写了一个 console 程序 ：</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">process_commands</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">line</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">line</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">):</span>
            <span class="n">line</span> <span class="o">+=</span> <span class="n">read_next_char</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">line</span> <span class="o">==</span> <span class="s1">&#39;quit</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">:</span>
            <span class="k">print</span> <span class="s2">&quot;are you sure?&quot;</span>
            <span class="k">if</span> <span class="n">read_next_char</span><span class="p">()</span> <span class="o">!=</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
                <span class="k">continue</span>    <span class="c1"># ignore the command</span>
        <span class="n">process_command</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</pre></div>


<p> 你想把它变成一个 GUI 程序 ， 然而 GUI 框架一般是基于事件的 ， 所以应该如何从 <code>read_next_char</code> 里读到下一个字符 ，
 同时又不阻塞执行呢 ？ 一般我们采用多线程 ， 让 UI 线程和上面的线程进行线程间同步 。 但是写过多线程的同学应该都知道 ，
 锁的数量多了之后很容易把程序弄得一团糟 。</p>
<p> 一个解决方法是使用 greenlet：</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">event_keydown</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
         <span class="c1"># jump into g_processor, sending it the key</span>
    <span class="n">g_processor</span><span class="o">.</span><span class="n">switch</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">read_next_char</span><span class="p">():</span>
        <span class="c1"># g_self is g_processor in this simple example</span>
    <span class="n">g_self</span> <span class="o">=</span> <span class="n">greenlet</span><span class="o">.</span><span class="n">getcurrent</span><span class="p">()</span>
        <span class="c1"># jump to the parent (main) greenlet, waiting for the next key</span>
    <span class="n">next_char</span> <span class="o">=</span> <span class="n">g_self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">switch</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">next_char</span>

<span class="n">g_processor</span> <span class="o">=</span> <span class="n">greenlet</span><span class="p">(</span><span class="n">process_commands</span><span class="p">)</span>
<span class="n">g_processor</span><span class="o">.</span><span class="n">switch</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>   <span class="c1"># input arguments to process_commands()</span>

<span class="n">gui</span><span class="o">.</span><span class="n">mainloop</span><span class="p">()</span>
</pre></div>


<p> 代码整个和多线程很类似 ， 但是由于 greenlet 采用了显式的 context 切换 ， 所以完全没有必要存在锁 。</p>
<p> 需要注意到的是上面用到了 gevent 的 parent。parent 默认会指向创建这个 greenlet 的 greenlet，
 上面的 <code>g_processor</code> 是在最外层定义的 ， 那么它的 parent 应该是谁呢 ？</p>
<p> 在 greenlet 的语境里 ， 认为程序开始运行时在主 greenlet 里 （ 类似于主线程和主进程的概念 ）， 所以在最外层创建的 greenlet，
 其 parent 就是主 greenlet(main)。</p>
<p>parent 除了用于方便索引外 ， 另一个意义在于当 greenlet 退出时会自动 switch 到它的 parent。 比如 ：</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">greenlet</span> <span class="kn">import</span> <span class="n">greenlet</span>

<span class="k">def</span> <span class="nf">test1</span><span class="p">():</span>
    <span class="k">print</span> <span class="mi">12</span>
    <span class="n">gr2</span><span class="o">.</span><span class="n">switch</span><span class="p">()</span>
    <span class="k">print</span> <span class="mi">34</span>
    <span class="k">return</span> <span class="s1">&#39;1 return&#39;</span>

<span class="k">def</span> <span class="nf">test2</span><span class="p">():</span>
    <span class="k">print</span> <span class="mi">56</span>
    <span class="k">print</span> <span class="mi">78</span>
    <span class="k">return</span> <span class="s1">&#39;2 return&#39;</span>

<span class="n">gr1</span> <span class="o">=</span> <span class="n">greenlet</span><span class="p">(</span><span class="n">test1</span><span class="p">)</span>
<span class="n">gr2</span> <span class="o">=</span> <span class="n">greenlet</span><span class="p">(</span><span class="n">test2</span><span class="p">)</span>
<span class="k">print</span> <span class="n">gr1</span><span class="o">.</span><span class="n">switch</span><span class="p">()</span>
</pre></div>


<p><code>gr2</code> 退出之后自动 switch 到其 parent， 也就是 main， 因此 main 中的 <code>gr1.switch</code> 返回了 test2 的返回值 ， 整个输出如下 ：</p>
<div class="highlight"><pre><span></span>12
56
78
2 return
</pre></div>


<h1>libev</h1>
<p><a href="http://software.schmorp.de/pkg/libev.html">libev</a> 是 gevent 的另一个依赖 。 最初的时候 gevent 使用的是 libevent，
 后来换成了 libev。</p>
<p>libevent 和 libev 从功能上来看差距不大 ， 主要是对操作系统层面的一些系统提供统一的封装 。 在 linux 上 ，
 它们都使用了 epoll 作为底层的基础 。 在 <a href="http://stackoverflow.com/a/13999821"> 设计理念 </a> 上 ，libev 更倾向于 UNIX 哲学 ，
 而 libevent 则提供了完整的事件驱动编程框架 。</p>
<p><a href="https://www.ibm.com/developerworks/aix/library/au-libev/"> 这里 </a> 有一些 libev 和 libevent 的例子 ， 基本上就是 ：</p>
<ol>
<li> 注册回调函数 。</li>
<li> 启动主循环 ， 监测事件 。</li>
</ol>
<h1>gevent</h1>
<p><a href="http://www.gevent.org/">gevent</a> 基于了上面介绍的 greenlet 和 libev。</p>
<ol>
<li> 将 Python 标准库中的一部分阻塞调用重写为异步调用 ， 并保持 API 一致 ， 以便运行时直接替换 (monkey_patch)。</li>
<li> 实现了 TCP/UDP/HTTP/WSGI 服务器 。</li>
<li> 加强了 DNS 查询的性能 。</li>
</ol>
<p> 它的运行过程大概是 ：</p>
<ol>
<li>main greenlet</li>
<li> 任意 gevent API 被调用 </li>
<li> 查找 Hub greenlet； 若不存在 ， 则创建一个 </li>
<li>Hub greenlet 调用 libev 监听事件 ， 进行调度 </li>
</ol>
<p> 一般来说 ， 在程序开头执行如下代码 ：</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">gevent</span> <span class="kn">import</span> <span class="n">monkey</span>
<span class="n">monkey</span><span class="o">.</span><span class="n">patch_all</span><span class="p">()</span>
</pre></div>


<p> 你的程序就已经运行在 gevent 之下了 ， 之后你就可以像使用线程和进程一样使用 Greenlet 了 。</p>
<p> 或者对于服务器而言 ， 你可以基于 gevent 提供的服务器实现具体的逻辑 ， 接着简单地 start 等待事件 （ 比如用户链接 ）
 来调用你的回调就好了 。</p>
<p>gevent 用 Greenlet 来替代线程和进程作为调度单位 ， 一方面缓解了线程和进程在较高的并发场景下开销大 ， 切换速度慢 
 等问题 。 另一方面用 Greenlet 来代替线程 + 锁实现协程 ， 更加的高效 。</p>
<p> 但是 Gevent 的问题在于实际上只有一个线程在执行 ， 所以如果你的某个 Greenlet 长时间占用 CPU， 那么 Hub 没法进入 CPU 进行调度 ，
 那么用户请求就被阻塞了 。 不过这个对于习惯了事件驱动编程的 Javascript、QT 的同学应该都不是问题 。</p>
<p> 总的来说 ，gevent 在非并行的 Python 上实现了原本不支持的异步编程 ， 对于实现高并发服务器来说十分友好 。</p>
<p> 从架构角色的角度来说 ， 我觉得可以这么说 ，gevent 在 Python 层面上基于 libev 实现了 libevent 的角色 。</p>
<p><strong>asyncio 的内容晚些再补 </strong></p>
  </div>
  <div class="tag-cloud">
    <p>
    </p>
  </div>




<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'huiyiqun';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>
        Please enable JavaScript to view comments.

</noscript>
</article>

    <footer>
<p>&copy; Hui Yiqun 2017</p>
<p>    Powered by <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a>
</p>    </footer>
  </main>

<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-89649249-1', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->



<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Notepad ",
  "url" : "../../..",
  "image": "https://secure.gravatar.com/avatar/e96680ba97e70a013f818edde6753ca8?s=120",
  "description": ""
}
</script>
</body>
</html>